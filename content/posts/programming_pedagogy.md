---
title: Pedagogy of Programming
date: 2023-03-10
tags: ['computing']
draft: false
---

Like most, when I was a beginner I went through a phase of questioning what's the best way to learn programming. I'm well past that phase now, but the question still interests me, because of how many friends ask me the same thing. I think programming is the best way for high IQ NEETs to get an income, so I'll write my thoughts on how to start learning here.

Yaron Minsky of Jane Street [has written a post about the problem](https://blog.janestreet.com/how-to-choose-a-teaching-language/), I mostly agree and I'd like to add some things to that.

The first point is that when you start learning with **C**, you have the machine's architectural details to guide you somehow on what you can and can't do. This is often said to be a negative of starting with C, as if you get bogged down in details you don't need to know about instead of focusing on problem solving, but I believe this is wrong: you don't have actual problems to solve when you first learn programming, you are dealing with contrived ones, and whether they are contrived to suit with C education or with Python/whatever else education doesn't matter. Low-level programming doesn't block your way to some ideal "problem solving" state then. C is a simple language that makes you understand some basic facts going on under the hood, e.g. that arrays are continuous slots in memory, or variables have a specific number of bits saved, or that ASCII letters are just 8-bit numbers just printed differently, stuff like that which gives you some natural limits on what is possible.

The second point is about functional programming and **LISP/Scheme** specifically. I agree that **functional programming** does have pedagogical value similarly to what I pointed above: the "mathematical foundations of computation" instead of the architectural details this time provide the beginner with a guideline on how to program. The functional curriculum essentially introduces very basic computation in the form of recursive functions that do pattern matching. This pattern matching is applied to simple data types like lists. Then, more complex data structures like graphs/trees are introduced, and the functions written for lists are naturally carried over to these. So a filter() function on a list becomes a filter() on a tree type, and the progression seems natural. This is opposed to imperative curriculums where everything becomes possible after loops are introduced, and so a lot of students become confused.

But all of these points about functional programming apply more to a language like OCaml than to LISP/Scheme, which not only has confusing syntax but also lacks many other important features characteristic of functional programming (and strong static typing perhaps even more importantly). The syntax needed is minimal in OCaml as it is in LISP, so that's not a good argument either. Algebraic data types, strong static typing, pattern matching, monads, those are some of the features that mainstream languages are just now implementing in often botched form that ML languages already had 40 years ago. So learning them properly is a valuable transferrable knowledge. Otherwise, functional programming languages are almost never used in the industry, but they're a huge meme as a proxy for high IQ. SICP gang often uses functional programming [as an end and not as a means.](https://blog.janestreet.com/do-you-use-fp-as-a-means-rather-than-an-end/).

The 3rd point is about **Python**. It is mentioned that the language itself might look simple but under the hood it's a lot complicated and lacks the benefits of the 2 previous approached I mentioned, namely having something to step on, whether that is the machine or mathematical foundations. But it's still a good alternative if someone tries the above and doesn't like them.

**Java** and many other languages provide none of the benefits of the above and add a lot of initial complexity with the OOP concepts so I think it's pointless to start with it. **Javascript** is inconsistent, it's sometimes recommended because you can immediately visually see the results of programming on the browser but it's a convoluted approach.