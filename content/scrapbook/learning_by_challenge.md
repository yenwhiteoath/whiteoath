---
title: Learning by challenge
date: 2022-10-08
tags: ['productivity']
draft: false
---

**jandrewrogers on Sept 7, 2013**

There is an alternative approach that inadvertently worked for me that may work well for you, particularly if your goal is to learn things beyond a conventional computer science curriculum. I have been working in high-end theoretical computer science for many years, with significant advances to my credit, but I went to school for chemical engineering. People are often curious as to how I acquired so much esoteric domain expertise in theoretical computer science without spending any time in a computer science class.

Pick an interesting "hard" problem in computer science and attempt to solve it. This works best if either there are no published solutions (e.g. massively parallelizing ad hoc graph search} or the solution space varies widely under the possible parameters (e.g. the design of a unique high-performance database kernel). Iterate, be creative, search the literature for interesting ideas that you can borrow from, and evaluate new designs you come up with. If something does not work, understand how and why and try to fix it. Wash, rinse, repeat.

This sounds like a lot of work, and it is, but there are three unique upsides. First, the challenge of it can be quite a bit of fun in its own right and there is a clear goal of what you are trying to achieve which helps keep you motivated and measures progress. Second, you will cover more of the phase space and explore some tangential theoretical areas while hunting for solutions to narrow subproblems that you would never be exposed to in a more structured setting. Third, you will invariably explore some unusual or unorthodox ideas that you simply would not be exposed to in a directed, formal program. From the standpoint of being an effective theoretical computer scientist, it will help you develop a unique perspective of the problem space that is different than the perspective that arises from more structured programs.

Also, you might actually solve one of the unsolved theoretical computer science problems you have as your challenge in addition to developing a deep understanding of the surrounding problem space. That happened to me (and then replicated later once I realized it was possible) and it would never happen if I was simply taking courses on the subject matter.

This was an effective way for me to gain in-depth understanding of a diverse range of theoretical computer science areas on an informal basis. One of the downsides is that your rote knowledge will not perfectly overlap what is taught in CS curricula even though what you do know will likely be more valuable (e.g. in spatial indexing some CS courses teach priority trees even though they have no memorable theoretical value).